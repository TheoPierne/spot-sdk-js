

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> bosdyn-client/power.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Spot-sdk-js</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/TheoPierne/spot-sdk-js"
                        >
                            Github spot-sdk-js
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://github.com/TheoPierne/spot-server-js"
                        >
                            Github spot-server-js
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AddRequestHeader.html">AddRequestHeader</a></li><li><a href="ArmSurfaceContactClient.html">ArmSurfaceContactClient</a></li><li><a href="AsyncGRPCTask.html">AsyncGRPCTask</a></li><li><a href="AsyncPeriodicGRPCTask.html">AsyncPeriodicGRPCTask</a></li><li><a href="AsyncPeriodicQuery.html">AsyncPeriodicQuery</a></li><li><a href="AsyncTasks.html">AsyncTasks</a></li><li><a href="AuthClient.html">AuthClient</a></li><li><a href="DataAcquisitionClient.html">DataAcquisitionClient</a></li><li><a href="DataAcquisitionPluginClient.html">DataAcquisitionPluginClient</a></li><li><a href="DataAcquisitionStoreClient.html">DataAcquisitionStoreClient</a></li><li><a href="DataServiceClient.html">DataServiceClient</a></li><li><a href="DirectoryClient.html">DirectoryClient</a></li><li><a href="DoorClient.html">DoorClient</a></li><li><a href="FaultClient.html">FaultClient</a></li><li><a href="GrpcRequests.html">GrpcRequests</a></li><li><a href="GrpcResponses.html">GrpcResponses</a></li><li><a href="LicenseClient.html">LicenseClient</a></li><li><a href="LocalGridClient.html">LocalGridClient</a></li><li><a href="LogAnnotationClient.html">LogAnnotationClient</a></li><li><a href="ManipulationApiClient.html">ManipulationApiClient</a></li><li><a href="MessageChannel.html">MessageChannel</a></li><li><a href="NetworkComputeBridgeClient.html">NetworkComputeBridgeClient</a></li><li><a href="PayloadClient.html">PayloadClient</a></li><li><a href="PointCloudClient.html">PointCloudClient</a></li><li><a href="PowerClient.html">PowerClient</a></li><li><a href="Robot.html">Robot</a></li><li><a href="RobotCommandClient.html">RobotCommandClient</a></li><li><a href="RobotIdClient.html">RobotIdClient</a></li><li><a href="RobotStateClient.html">RobotStateClient</a></li><li><a href="Sdk.html">Sdk</a></li><li><a href="TokenCacheFilesystem.html">TokenCacheFilesystem</a></li><li><a href="TokenManager.html">TokenManager</a></li><li><a href="TypedMessageChannel.html">TypedMessageChannel</a></li><li><a href="WorldObjectClient.html">WorldObjectClient</a></li><li>{<a href="ArmSurfaceContactClient.html">ArmSurfaceContactClient</a>}</li><li>{<a href="AsyncPeriodicQuery.html">AsyncPeriodicQuery</a>}</li><li>{<a href="AuthClient.html">AuthClient</a>}</li><li>{<a href="DataAcquisitionPluginClient.html">DataAcquisitionPluginClient</a>}</li><li>{<a href="DataAcquisitionStoreClient.html">DataAcquisitionStoreClient</a>}</li><li>{<a href="RobotIdClient.html">RobotIdClient</a>}</li></ul><h3>Global</h3><ul><li><a href="global.html#_power_command">_power_command</a></li><li><a href="global.html#add_edge_to_tree">add_edge_to_tree</a></li><li><a href="global.html#block_for_trajectory_cmd">block_for_trajectory_cmd</a></li><li><a href="global.html#block_until_arm_arrives">block_until_arm_arrives</a></li><li><a href="global.html#blocking_selfright">blocking_selfright</a></li><li><a href="global.html#blocking_sit">blocking_sit</a></li><li><a href="global.html#blocking_stand">blocking_stand</a></li><li><a href="global.html#build_pc_request">build_pc_request</a></li><li><a href="global.html#create_insecure_channel">create_insecure_channel</a></li><li><a href="global.html#create_secure_channel">create_secure_channel</a></li><li><a href="global.html#create_secure_channel_creds">create_secure_channel_creds</a></li><li><a href="global.html#create_standard_sdk">create_standard_sdk</a></li><li><a href="global.html#decode_token">decode_token</a></li><li><a href="global.html#DEFAULT_MAX_MESSAGE_LENGTH">DEFAULT_MAX_MESSAGE_LENGTH</a></li><li><a href="global.html#express_se2_velocity_in_new_frame">express_se2_velocity_in_new_frame</a></li><li><a href="global.html#express_se3_velocity_in_new_frame">express_se3_velocity_in_new_frame</a></li><li><a href="global.html#generate_channel_options">generate_channel_options</a></li><li><a href="global.html#get_a_tform_b">get_a_tform_b</a></li><li><a href="global.html#get_frame_names">get_frame_names</a></li><li><a href="global.html#get_odom_tform_body">get_odom_tform_body</a></li><li><a href="global.html#get_se2_a_tform_b">get_se2_a_tform_b</a></li><li><a href="global.html#get_vision_tform_body">get_vision_tform_body</a></li><li><a href="global.html#has_arm">has_arm</a></li><li><a href="global.html#is_gravity_aligned_frame_name">is_gravity_aligned_frame_name</a></li><li><a href="global.html#is_powered_on">is_powered_on</a></li><li><a href="global.html#log_token_time_remaining">log_token_time_remaining</a></li><li><a href="global.html#make_add_world_object_req">make_add_world_object_req</a></li><li><a href="global.html#make_change_world_object_req">make_change_world_object_req</a></li><li><a href="global.html#make_delete_world_object_req">make_delete_world_object_req</a></li><li><a href="global.html#power_cycle_robot">power_cycle_robot</a></li><li><a href="global.html#power_off_motors">power_off_motors</a></li><li><a href="global.html#power_off_payload_ports">power_off_payload_ports</a></li><li><a href="global.html#power_off_robot">power_off_robot</a></li><li><a href="global.html#power_off_wifi_radio">power_off_wifi_radio</a></li><li><a href="global.html#power_on_motors">power_on_motors</a></li><li><a href="global.html#power_on_payload_ports">power_on_payload_ports</a></li><li><a href="global.html#power_on_wifi_radio">power_on_wifi_radio</a></li><li><a href="global.html#RefreshingAccessTokenAuthMetadataPlugin">RefreshingAccessTokenAuthMetadataPlugin</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#ResponseContext">ResponseContext</a></li><li><a href="global.html#safe_power_off">safe_power_off</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#shift_pan_angle">shift_pan_angle</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#translate_exception">translate_exception</a></li><li><a href="global.html#validate_frame_tree_snapshot">validate_frame_tree_snapshot</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>bosdyn-client/power.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const { setTimeout: sleep } = require('node:timers/promises');
const { BaseClient, error_factory } = require('./common');
const { ResponseError, InternalServerError, LicenseError, TimedOutError } = require('./exceptions');
const { add_lease_wallet_processors } = require('./lease');

const basic_command_pb = require('../bosdyn/api/basic_command_pb');
const full_body_command_pb = require('../bosdyn/api/full_body_command_pb');
const license_pb = require('../bosdyn/api/license_pb');
const power_pb = require('../bosdyn/api/power_pb');
const power_service_grpc_pb = require('../bosdyn/api/power_service_grpc_pb');
const robot_command_pb = require('../bosdyn/api/robot_command_pb');
const robot_state_pb = require('../bosdyn/api/robot_state_pb');

class PowerResponseError extends ResponseError {
  constructor(msg) {
    super(null, msg);
    this.name = 'PowerResponseError';
  }
}

class ShorePowerConnectedError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'ShorePowerConnectedError';
  }
}

class BatteryMissingError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'BatteryMissingError';
  }
}

class CommandInProgressError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'CommandInProgressError';
  }
}

class EstoppedError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'EstoppedError';
  }
}

class FaultedError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'FaultedError';
  }
}

class PowerError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'PowerError';
  }
}

class CommandTimedOutError extends PowerResponseError {
  constructor(msg) {
    super(msg);
    this.name = 'CommandTimedOutError';
  }
}

/**
 * A client for enabling / disabling robot motor power.
 * Commands are non blocking. Clients are expected to issue a power command and then periodically
 * check the status of this command.
 * This service requires ownership over the robot, in the form of a lease.
 * @extends {BaseClient}
 */
class PowerClient extends BaseClient {
  static default_service_name = 'power';
  static service_type = 'bosdyn.api.PowerService';

  constructor() {
    super(power_service_grpc_pb.PowerServiceClient);
  }

  update_from(other) {
    super.update_from(other);
    if (this.lease_wallet) add_lease_wallet_processors(this, this.lease_wallet);
  }

  power_command(request, lease = null, args) {
    const req = PowerClient._power_command_request(lease, request);
    return this.call(this._stub.powerCommand, req, null, _power_command_error_from_response, args);
  }

  power_command_feedback(power_command_id, args) {
    const req = PowerClient._power_command_feedback_request(power_command_id);
    return this.call(
      this._stub.powerCommandFeedback,
      req,
      _power_status_from_response,
      _power_feedback_error_from_response,
      args,
    );
  }

  static _power_command_request(lease, request) {
    return new power_pb.PowerCommandRequest().setLease(lease).setRequest(request);
  }

  static _power_command_feedback_request(power_command_id) {
    return new power_pb.PowerCommandFeedbackRequest().setPowerCommandId(power_command_id);
  }
}

function _handle_license_errors(func) {
  function wrapper(args, kwargs) {
    return _common_license_errors(args) || func(args, kwargs);
  }
  return wrapper;
}

function _common_license_errors(response) {
  let license_status = null;
  if (response.getStatus() !== power_pb.PowerCommandStatus.STATUS_LICENSE_ERROR) return null;
  if (response.getLicenseStatus()) {
    license_status = response.getLicenseStatus();
  } else {
    return new InternalServerError(response, 'No LicenseInfo.Status field found!');
  }
  if (license_status !== license_pb.LicenseInfo.Status.STATUS_VALID) return new LicenseError(response);

  return null;
}

const _STATUS_TO_ERROR = {
  [power_pb.PowerCommandStatus.STATUS_SUCCESS]: [null, null],
  [power_pb.PowerCommandStatus.STATUS_IN_PROGRESS]: [null, null],
  [power_pb.PowerCommandStatus.STATUS_SHORE_POWER_CONNECTED]: [
    ShorePowerConnectedError,
    'Robot cannot be powered on while on wall power.',
  ],
  [power_pb.PowerCommandStatus.STATUS_BATTERY_MISSING]: [BatteryMissingError, 'Battery not inserted into robot.'],
  [power_pb.PowerCommandStatus.STATUS_COMMAND_IN_PROGRESS]: [
    CommandInProgressError,
    'Power command cannot be overwritten.',
  ],
  [power_pb.PowerCommandStatus.STATUS_ESTOPPED]: [
    EstoppedError,
    'Cannot power on while estopped. Inspect EStopState for more info.',
  ],
  [power_pb.PowerCommandStatus.STATUS_FAULTED]: [
    FaultedError,
    'Cannot power on due to a fault. Inspect FaultState for more info.',
  ],
  [power_pb.PowerCommandStatus.STATUS_INTERNAL_ERROR]: [
    InternalServerError,
    'Service experienced an unexpected error state.',
  ],
  [power_pb.PowerCommandStatus.STATUS_LICENSE_ERROR]: [
    LicenseError,
    'Request was rejected due to using an invalid license.',
  ],
};

function _power_command_error_from_response(response) {
  return error_factory(response, response.getStatus(), Object.keys(power_pb.PowerCommandStatus), _STATUS_TO_ERROR);
}

// eslint-disable-next-line
function _power_feedback_error_from_response(response) {
  return null;
}

function _power_status_from_response(response) {
  return response.getStatus();
}

/**
 * Power off robot motors safely. This function blocks until robot safely powers off. This
 * means the robot will attempt to sit before powering motors off.
 *
 * @param {RobotCommandClient} command_client Client for calling RobotCommandService safe power off.
 * @param {RobotStateClient} state_client Client for monitoring power state.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_sec.
 * @throws {RobotCommandResponseError} Something went wrong during the power off sequence.
 */
async function safe_power_off(command_client, state_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const start_time = Date.now();
  const end_time = start_time + timeout_msec;
  const update_time = 1.0 / update_frequency;

  const full_body_command = new full_body_command_pb.FullBodyCommand.Request().setSafePowerOffRequest(
    new basic_command_pb.SafePowerOffCommand.Request(),
  );
  const command = new robot_command_pb.RobotCommand().setFullBodyCommand(full_body_command);
  await command_client.robot_command(command, args);

  /* eslint-disable no-await-in-loop */
  while (Date.now() &lt; end_time) {
    const time_until_timeout = end_time - Date.now();
    const start_call_time = Date.now();
    try {
      const response = await state_client.get_robot_state(Object.assign({}, args, { timeout: time_until_timeout }));
      if (response.getPowerState().getMotorPowerState() === robot_state_pb.PowerState.MotorPowerState.STATE_OFF) return;
    } catch (e) {
      throw new CommandTimedOutError(e);
    }
    const call_time = Date.now() - start_call_time;
    const sleep_time = Math.max(0.0, update_time - call_time);
    await sleep(sleep_time);
  }
  /* eslint-enable no-await-in-loop */

  throw new CommandTimedOutError();
}

async function power_on(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  console.warn('[POWER] Replaced by the less ambiguous power_on_motors function.');
  await power_on_motors(power_client, timeout_msec, update_frequency, args);
}

async function power_off(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  console.warn('[POWER] Replaced by the less ambiguous power_off_motors function.');
  await power_off_motors(power_client, timeout_msec, update_frequency, args);
}

/**
 * Power on the robot motors. This function blocks until the command returns success.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_on_motors(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_ON_MOTORS;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Power off the robot motors.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_off_motors(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_OFF_MOTORS;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Fully power off the robot. Powering off the robot will stop API comms.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_off_robot(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_OFF_ROBOT;
  await _power_command(power_client, request, timeout_msec, update_frequency, true, args);
}

/**
 * Power cycle the robot. Power cycling the robot will stop API comms.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_cycle_robot(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_CYCLE_ROBOT;
  await _power_command(power_client, request, timeout_msec, update_frequency, true, args);
}

/**
 * Power off the robot payload ports.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_off_payload_ports(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_OFF_PAYLOAD_PORTS;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Power on the robot payload ports.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_on_payload_ports(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_ON_PAYLOAD_PORTS;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Power off the robot Wi-Fi radio.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_off_wifi_radio(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_OFF_WIFI_RADIO;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Power on the robot Wi-Fi radio.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for.
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot.
 * @throws {CommandTimedOutError} Did not power off within timeout_msec.
 * @throws {PowerResponseError} Something went wrong during the power off sequence.
 */
async function power_on_wifi_radio(power_client, timeout_msec = 30_000, update_frequency = 1.0, args) {
  const request = power_pb.PowerCommandRequest.Request.REQUEST_ON_WIFI_RADIO;
  await _power_command(power_client, request, timeout_msec, update_frequency, undefined, args);
}

/**
 * Helper function to issue command to power client.
 *
 * @param {PowerClient} power_client Client for calling power service.
 * @param {PowerCommandRequest} request Request to make to power service.
 * @param {number} [timeout_msec=30000] Max time this function will block for (in milliseconds).
 * @param {number} [update_frequency=1.0] The frequency with which the robot should check if the command has succeeded.
 * @param {boolean} [expect_grpc_timeout=false] Expect API comms to drop on a success.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;void>}
 * @throws {RpcError} Problem communicating with the robot
 */
async function _power_command(
  power_client,
  request,
  timeout_msec = 30_000,
  update_frequency = 1.0,
  expect_grpc_timeout = false,
  args,
) {
  let responseId;

  try {
    responseId = await power_client.power_command(request, undefined, args);
  } catch (e) {
    console.log(e);
    if (e instanceof TimedOutError) {
      if (expect_grpc_timeout) {
        return;
      } else {
        throw e;
      }
    }
  }

  if (responseId.getStatus() === power_pb.PowerCommandStatus.STATUS_SUCCESS) return;

  const start_time = Date.now();
  const end_time = start_time + timeout_msec;
  const update_time = 1.0 / update_frequency;

  const power_command_id = responseId.getPowerCommandId();

  /* eslint-disable no-await-in-loop */
  while (Date.now() &lt; end_time) {
    const time_until_timeout = end_time - Date.now();
    const start_call_time = Date.now();
    try {
      const response = await power_client.power_command_feedback(
        power_command_id,
        Object.assign({}, args, { timeout: time_until_timeout }),
      );
      if (response === power_pb.PowerCommandStatus.STATUS_SUCCESS) return;
      if (response !== power_pb.PowerCommandStatus.STATUS_IN_PROGRESS) {
        const error_type = _STATUS_TO_ERROR[response][0];
        const message = _STATUS_TO_ERROR[response][1];
        throw new error_type(message);
      }
    } catch (e) {
      const errorClass = Object.values(_STATUS_TO_ERROR)
        .map(x => x[0])
        .filter(x => x !== null);
      if (e instanceof TimedOutError) {
        if (expect_grpc_timeout) {
          return;
        } else {
          throw e;
        }
      } else if (!errorClass.some(classError => e instanceof classError)) {
        throw new CommandTimedOutError(e);
      } else {
        throw e;
      }
    }
    const call_time = Date.now() - start_call_time;
    const sleep_time = Math.max(0.0, update_time - call_time);
    console.log(update_time - call_time);
    await sleep(sleep_time);
  }
  /* eslint-enable no-await-in-loop */

  throw new CommandTimedOutError();
}

/**
 * Returns true if robot is powered on, false otherwise.
 *
 * @param {RobotStateClient} state_client Robot state client instance.
 * @param {Object} [args] Extra arguments for controlling RPC details.
 * @returns {Promise&lt;boolean>}
 * @throws {RpcError} Problem communicating with the robot
 */
async function is_powered_on(state_client, args) {
  const response = await state_client.get_robot_state(args);
  return response.getPowerState().getMotorPowerState() === robot_state_pb.PowerState.MotorPowerState.STATE_ON;
}

module.exports = {
  PowerResponseError,
  ShorePowerConnectedError,
  BatteryMissingError,
  CommandInProgressError,
  EstoppedError,
  FaultedError,
  PowerError,
  CommandTimedOutError,
  PowerClient,
  safe_power_off,
  power_on,
  power_off,
  power_on_motors,
  power_off_motors,
  power_off_robot,
  power_cycle_robot,
  power_off_payload_ports,
  power_on_payload_ports,
  power_off_wifi_radio,
  power_on_wifi_radio,
  is_powered_on,
};
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
